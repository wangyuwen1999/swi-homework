# 问题解答：Pseudocode (伪代码)
## 1）用伪代码描述将十进制转化为十六进制的方法：
解：

    1.x<--十进制数
    2.i<--1
    3.j<--1
    4.while (x/16)!=0
        1. do if(x%16>9)
          then [
            1.if(x%16=10)
                then [y[i]<--A]
            2.if(x%16=11)
                then [y[i]<--B]
            3.if(x%16=12)
                then [y[i]<--C]
            4.if(x%16=13)
                then [y[i]<--D]
            5.if(x%16=14)
                then [y[i]<--E]
            6.if(x%16=14)
                then [y[i]<--F]
        ]
        2.else 
          then [ y[i]<--(x%16)]
        3.i<--i+1
        4.x<--(x/16)
    5.y[i]<--x
    6.for i<--i to 1
        1.z[j]<--y[i]
        2.j<--j+1 
## 2)C语言实现：

    int x;
    char y[100];
    char z[100];
    int i=0;
    int j=0;

    scanf("%d",&x);        //scanf一个十进制数并保存于变量x中；

    while(x/16!=0){        //while（x/16的整数部分不为0）

            if(x%16>9){    // if（x%16的余数大于9）将其对应十六进制数字母存在字符数组y的第i个位置
                if(x%16=10)y[i]=A;
                if(x%16=11)y[i]=B;
                if(x%16=12)y[i]=C;
                if(x%16=13)y[i]=D;
                if(x%16=14)y[i]=E;
                if(x%16=15)y[i]=F;
            }

            else y[i]=(x%16)+'0';   // else将数字存入y数组

            ++i;                    //  i的值加一

            x=x/16 ;                // x的值变为x/16的整数部分
    }

    y[i]=x+'0';             //while循环结束，将x存入y数组

    while(i>=0){            //用z数组将y数组中元素反向排列
        z[j]=y[i];
        ++j;
    }
## 3）数据测试：
    -1     -1
     0      0  
     1      1
     15     F
     26     1A
     3265   CC1



